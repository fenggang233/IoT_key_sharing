## 定义
>秘密共享的思想是将秘密以适当的方式拆分，拆分后的每一个份额由不同的参与者管理，单个参与者无法恢复秘密信息，只有若干个参与者一同协作才能恢复秘密消息。更重要的是，当其中任何相应范围内参与者出问题时，秘密仍可以完整恢复。~~~（why？）~~~

>秘密共享的关键是怎样更好的设计秘密拆分方式和恢复方式。

### 门限秘密共享：
>(k,n)门限秘密共享表示把秘密信息分成n份无意义的子秘密，只有拥有至少k份子秘密才能恢复秘密信息。k<=n。

### shamir算法

1. 拉格朗日插值（已知k个点可以确定唯一一个k-1次曲线）
2. 这里考虑加入取模行为后的算法实现。


```
1.秘密分发
  秘密s转换成一个整数s0，选取k-1个随机数s1，s2，...，s(k-1)和一个大素数p
 （p大于多项式中任意一个项的系数，且p公开）
  构成多项式f(x) = {s0+s1*x+s2*x^2+...+s(k-1)*x^(k-1)}mod p
  假定秘密要分发给n个人，则公开x1,x2,...,xn.
  要分发的秘密就是(x1,f(x1)),(x2,f(x2)),...(xn,f(xn))
2.秘密还原
  只需要k个人共享其被分发到的秘密（也就是点值对），就可以使用使用拉格朗日插值公式还原
  进而得到秘密s=s0
  这里插值公式应该是模p下的插值公式
```

## 基于身份的加密方案

由四个部分构成：建立，密钥提取，加密和解密


```
Setup(k)->PK,MSK:建立算法以安全参数k为输入，输出为公共参数PK和主密码MSK。

KeyGen(PK,MSK,ID)->SK(ID):密钥提取算法以公共参数PK，主密钥MSK和一个身份信息ID为输入
输出该身份信息对应的私钥SK(ID)

Encrypt(PK,M,SK(ID))->CT：加密算法以公共参数PK，明文消息M，以及接收者的身份信息ID为输入，输出密文CT

Decrypt(PK,CT,SK(ID))->M:输出为明文M
```

但是在传统IBE系统中，私钥生成中心不但要生成用户的私钥，还要验证用户的身份以及建立传输用户私钥的安全通道，负担比较重。

HIBE（分层的基于身份的加密方案）就应运而生了。在分层的系统中，PKG以树状结构分布，根PKG只为它下一层的PKG或用户产生私钥，下层的PKG又为它下一层的PKG或用户产生私钥，且身份的验证和私钥的传输也可以在局部完成。
并且在分层的系统中，低层PKG私钥的泄露不会影响高层PKG私钥的安全。

## IBE中的密钥托管问题

在基于身份的加密方案中，PKG使用主密钥生成用户的私钥，因此PKG可以解密任何信息，这是基于身份的加密方案固有的特点。但是实际情况中这个特质并不总是需要，此时就出现了密钥托管问题。

如何解决密钥托管问题呢？一个被提出的解决方法是使用基于门限秘密共享的方案，但它的计算量比较大，且并不能从根本上解决问题

另一个被提出的解决方法是基于证书的加密。在这个方案中，用户的私钥由用户选择的和CA产生的两部分组成，从而CA并不能知道用户完整的私钥，但这个解决方法需要CA颁发的证书，就丧失了IBE不需要证书的优点。

第三个也是比较有吸引力的方案是无证书密码方案，用户的私钥由用户选择的和PKG产生的两部分组成。

## IBE中的公钥撤销问题

若攻击者窃取了某个用户的私钥，PKG要怎么撤销该用户的公钥成为了另一个问题。

一个解决方案是私钥隔离的方式，把生命周期划分为N个时间段，公钥在生命期内固定不变，而私钥则随时间变化。


~~~ 接下来打算看看具体实现 ~~~

## 项目实现

（1）基于秘密共享的顶级节点参数生成算法

初始n个顶级节点共同参与， 可以协商出一个共同的未知的秘密作为虚拟顶级管理者保密安全参数（主私钥）， 并获得虚拟顶级管理者公共安全参数（主公钥） 和自己在虚拟顶级管理者内通信的节点私钥 1（域内主私钥 1），同时自动生成管理域并获得自己的节点私钥 2（域内主私钥 2）

1. 首先n个顶级节点各自选择一个n-1次多项式（模p的）。
2. 随后每个顶级节点使用自己选择的多项式，以n个顶级节点的ID为x计算出f(x),分发出去。
3. 分发完成后每个顶级节点都能获得n个多项式生成结果D(i,j)。这里注意由于D（i，i）是由顶级节点依据自己的ID值按照自己选择的多项式生成的结果，没有经历任何数据传输。这里的门限秘密共享是（n,n）的。
4. 设置 *** 公共系统安全参数 *** 为n个顶级节点选择的n个n-1次多项式常数项的和。并且所有顶级节点把把自己收到的n个f（x）值求和（D(k))。~~~ 有什么用? ~~~（用来准备做拉格朗日插值）
5. ~~~ 这里的扰动计算好像需要每两个节点把相互传输的信息共享 ~~~（节点k自己有选择的多项式f（x，k），然后n个节点的ID都是公开的，这样节点k随时都可以计算出将要发送给其他节点的D值，它还收到其他节点发给自己的结果，那么扰动都是可以本地计算的）.
6. 现在我们可以通过n个顶级节点共享信息使用拉格朗日插值获得F(0)(即 *** 公共系统安全参数 *** )
7. 现在进行二次参数分发，每个顶级节点向其他顶级节点发送自己构成拉格朗日插值的那一项乘上自己标识的哈希值
（*** 不管这个是什么，第四步中“对顶级节点U（0，k）（1<=j<=n,j!=k）发送Q（0，i）”这最后的i一定是错的，是不是j的意思？ ***） 
8. 每个顶级节点的私钥是获取的（？？所有拉格朗日插值项乘上一个公开信息哈希之后的和）和计算出公共参数。
9. 每个顶级节点选择一个s（0，k）作为自己管理域的保密安全参数，并计算s(0,k)P 作为自己管理域的公共参数。随后把自己管理域公共参数加上自己的ID打包哈希并加密后发给其他顶级节点（用于以后的跨域通信吧）
10. 最后顶级节点生成自己的数字签名。

（2）管理员节点参数节点更新算法
如果一个管理员节点需要进行更新，则它更新自己的参数，如果其非顶级节点则需要父节点参与，如果其为顶级节点则需要选取n个顶级节点（自己也是其中一个）共同参与。之后把参数告知自己的子节点， 要求其更新。如果子节点是管理员节点，则需要迭代更新验证消息和消息的签名。

1. 待更新节点生成更新值w，计算新的保密安全参数和新的公共安全参数。若是顶级节点，转6.
2. 待更新节点把新的保密安全参数加密后发给其父节点
3. 父节点获得子节点新的保密参数后，决定是否同意更新，若拒绝，则向子节点发送NAK
4. 父节点同意后向子节点发送相关信息
5. 子节点根据收到的信息对自己的参数进行更新。转9
6. 该待更新的顶级节点把相关消息发送给所有其他顶级节点。
7. 其他收到信息的顶级节点向子节点发送相关信息
8. 子节点更新相关信息
9. 递归更新所有的子管理节点

（3）非顶级节点的加入算法

1. 待加入节点把临时会话密钥发给管理节点
2. 管理节点收到后决定是否允许加入，拒绝发送NAK
3. 同意就计算出待加入节点的私钥并发送
4. 带加入节点保存私钥信息

（4）非顶级节点的退出
若非叶子节点，向所有子节点发送强制退出信息，等待子节点发送退出告知消息，向父节点发送退出告知信息，父节点收到后执行管理员参数更新算法

