## 基于Weil Pairing的IBE

~~~(论文介绍中提到即使攻击者可以从PKG那里获取任何ID对应的密钥，也不能击败该IBE系统，why？)~~~
因为在这里约定的选择密文攻击中，攻击者可以从PKG获取任意ID对应的密钥，在获取信息后再尝试自己根据准备攻击的ID破解出对应的密钥

### 1 IBE应用
**已发布密钥的撤销**
使用IBE加密系统时，可以通过在公钥内附加日期（日期的精度决定了密钥的有效时长）来实现密钥的到期检查。每当密钥到期，使用密钥解密信息的人就需要从PKG获得新密钥。且使用IBE加密并发送信息的人并不需要在接受信息者更新“证书”后重新获取对方的公钥。
并且，这种公钥方式还使得发送方可以给接收方发送指定日期才能解密的信息，在那之前，接收方的密钥都不能解密附加未来日期公钥加密的信息。


**解密密钥的托管**
1. 由于解密密钥是通过master key生成的，且一般具有时效性，所以解密密钥被盗损失较小
2. master key可以解密全部加密信息，使用IBE可以生成私钥，这个私钥只能解密对应公钥加密的信息，有效做到责任分派

### 2 定义
双线性映射。设G1和G2是两个阶为q（q为大质数）的循环群，在我们的加密体系中，G1是有限域上的椭圆曲线，G2是含有p^2个元素的不含0元素的有限群，当G1*G1→G2的映射e满足：e(aP,bQ)=e(P,Q)^(ab)，对所有G1内的P,Q都成立时，我们称这个映射是双线性映射。


### 3 weil pairing的特性

令p是一个质数，且满足p=2(mod 3),且p=6q-1,q是质数。椭圆曲线E是定义在有限域F(p)上：y^2=x^3+1.
对于这条曲线，我们有：
1. 这条有限域上的椭圆曲线有p+1个点。令点P是阶为q=(p+1)/6的点集的生成元，我们把这个子群记为G(q)
2. 对于有限域F(p)上的任意一个y0，都一定有一个唯一的x0与之对应使得(x0,y0)在E这条有限域的椭圆曲线上。
3. 令q∈F(p^2)，q!=1，且满足q^3-1=0 (mod p).则当(x,y)∈E/F(p)时，有(qx,y)∈E/F(p^2),但(qx,y)不属于E/F(p)
4. 定义修改后的weil pairing

Weil Diffie-Hellman Assumption
p = 2 mod 3是一个k比特的质数，且p=6q-1,q也是某个质数，定义有限域F(p)上的椭圆曲线y^2=x^3+1，P是其上的某个阶为q的点，给定(P,aP,bP,cP),其中a,b,c是非零的模q整数，计算修改后的weil pairing（P,P）^(abc)是困难的。
 
### 4 IBE实现

***
#### 4.1
p=2 mod 3,p=6q-1,p,q质数，E:y^2=x^3+1有限域上的椭圆曲线。
这里的IBE方案使用一个简单的算法MapToPoint把一串01字符串表示的ID表示为有限域椭圆曲线上的阶为q的点。

#### 4.2
首先介绍一个较为简单的IBE实现:BasicIdent
> setup:
> 1.p=2 mod 3,p=6q-1,p,q质数，E:y^2=x^3+1有限域上的椭圆曲线。
> 选取椭圆曲线上的阶为q的点P
> 2. 随机选取模q且非零的整数s，P(pub)=sP
> 3. 选取哈希函数H、G，H:F(p^2)→{0，1}^n;G:{0,1}*→F(p)
> 明文域{0,1}^n,密文域C=E/F(p)*{0,1}^n.
> 系统参数{p,n,P,P(pub),G,H}，master-key：s

****
> extract:
> 1. 使用算法MapToPoint把ID映射到有限域椭圆曲线上的阶为q的点Q(ID)
> 2. 私钥：d(ID)=sQ(ID)

****
> encrypt:
> 1. 使用算法MapToPoint把ID映射到有限域椭圆曲线上的阶为q的点Q(ID)
> 2. 选取模q的随机整数r
> 3. 计算修改后的weil pairing：g(ID)=e(Q(ID),P(pub))
> 4. 密文C={rP,M xor H( g(ID)^r )}

****
> Decrypt:
> 1. 已知密文{U,V}，首先检查U是否是有限域椭圆曲线上阶为q的点，不是的话拒绝解密。
> 2. M=V xor H( e(d(ID),U) )

#### 4.3
改造BasicIdent
> setup:除了BasicIdent里的步骤，再加上选择哈希函数H1,G1.H1:({0,1}^n) * ({0,1}^n) → F(q);G1:{0,1}^n → {0，1}^n
****
> extract:依照basicident的步骤
****
> encrypt:
> 1. 使用算法MapToPoint把ID映射到有限域椭圆曲线上的阶为q的点Q(ID)
> 2. 选择随机01且长度为n的字符串σ
> 3. r=H1(σ,M)
> 4. C={rP, σ xor H( g(ID)^n ), M xor G1(σ)},g(ID)=e(Q(ID),P(pub))
****
> decrypt:
> 1. 已知密文{U,V,W}，首先检查U是否是有限域椭圆曲线上阶为q的点，不是的话拒绝解密。
> 2. 计算σ = V xor H( e(d(ID),U) )
> 3. 计算M=W xor G1(σ)
> 4. r=H1(σ,M),检测U=rP，若等式不成立拒绝解密
> 5. 输出M





